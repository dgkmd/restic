package walker

import (
	"context"
	"fmt"
	"sort"
	"testing"

	"github.com/restic/chunker"
	"github.com/restic/restic/internal/archiver"
	"github.com/restic/restic/internal/repository"
	"github.com/restic/restic/internal/restic"
	rtest "github.com/restic/restic/internal/test"
	"golang.org/x/sync/errgroup"
)

// TestRewriter:
// Generate arbitrary tree hierarchy that consists of various node types.
// Also include various metadata to test metadata preservation.
// Prepare mock rechunkBlobsMap. (It doesn't have to be generated by real chunking)
// wants: dstRepo to have all tree blobs that are expected (substitued contents).
// Also include expected fail test case, in which a file with no matching key in rechunkBlobsMap exists.
// Number of dst blobs: max(round(an+b), 1),
// where n: number of src blobs, a~Uniform(0.9, 1.1) and b~Uniform(-2.0, 2.0).
// And each blob ID should be randomly generated 32 bytes string (SHA256 format).

func TestRechunker(t *testing.T) {
	ctx, cancel := context.WithCancel(context.TODO())
	defer cancel()
	repository.TestUseLowSecurityKDFParameters(t)

	// prepare repositories
	srcRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})
	dstTestsRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})
	dstWantsRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})

	srcChunkerParam, _ := chunker.RandomPolynomial()
	dstChunkerParam, _ := chunker.RandomPolynomial()

	repoVer := uint(restic.StableRepoVersion)
	repoPw := rtest.TestPassword
	_ = srcRepo.Init(ctx, repoVer, repoPw, &srcChunkerParam)
	_ = dstTestsRepo.Init(ctx, repoVer, repoPw, &dstChunkerParam)
	_ = dstWantsRepo.Init(ctx, repoVer, repoPw, &dstChunkerParam)

	// prepare test data
	src := archiver.TestDir{
		"0": archiver.TestFile{Content: ""},
		"1": archiver.TestFile{Content: string(rtest.Random(11, 123))},
		"2": archiver.TestFile{Content: string(rtest.Random(12, 123_456))},
		"3": archiver.TestFile{Content: string(rtest.Random(13, 9_000_000))},
		"4": archiver.TestFile{Content: string(rtest.Random(14, 10_000_000))},
		"5": archiver.TestFile{Content: string(rtest.Random(15, 11_000_000))},
	}
	dupFileContent := string(rtest.Random(16, 12_000_000))
	src["dup1"] = archiver.TestFile{Content: dupFileContent}
	src["dup2"] = archiver.TestFile{Content: dupFileContent}

	tempDir := rtest.TempDir(t)
	archiver.TestCreateFiles(t, tempDir, src)
	src = nil
	dupFileContent = ""

	// archive data to the repos with archiver
	srcSn := archiver.TestSnapshot(t, srcRepo, tempDir, nil)
	_ = archiver.TestSnapshot(t, dstWantsRepo, tempDir, nil)

	// do rechunking for dstTestRepo
	rechunker := NewRechunker(srcRepo, dstTestsRepo, dstTestsRepo.Config().ChunkerPolynomial)
	wg, wgCtx := errgroup.WithContext(ctx)
	dstTestsRepo.StartPackUploader(wgCtx, wg)
	rechunker.RechunkData(ctx, *srcSn.Tree)
	dstTestsRepo.Flush(ctx)

	// compare data blobs between dstWantsRepo and dstTestRepo
	blobWants := restic.IDs{}
	dstWantsRepo.ListBlobs(ctx, func(pb restic.PackedBlob) {
		if pb.Type == restic.DataBlob {
			blobWants = append(blobWants, pb.ID)
		}
	})

	for _, blobID := range blobWants {
		_, ok := dstTestsRepo.LookupBlobSize(restic.DataBlob, blobID)
		if !ok {
			t.Errorf("Blob missing: %v", blobID)
		}
	}

	fmt.Println(rechunker.rechunkBlobsMap)
}

func generateBlobIDsPair(nSrc, nDst uint) BlobIDsPair {
	srcIDs := make(restic.IDs, 0, nSrc)
	dstIDs := make(restic.IDs, 0, nDst)
	for range nSrc {
		srcIDs = append(srcIDs, restic.NewRandomID())
	}
	for range nDst {
		dstIDs = append(dstIDs, restic.NewRandomID())
	}

	return BlobIDsPair{srcBlobIDs: srcIDs, dstBlobIDs: dstIDs}
}

type TestNodeExtended struct {
	Type    restic.NodeType
	Size    uint64
	Content restic.IDs
}

func BuildTreeMapExtended(tree TestTree) (m TreeMap, root restic.ID) {
	m = TreeMap{}
	id := buildTreeMapExtended(tree, m)
	return m, id
}

func buildTreeMapExtended(tree TestTree, m TreeMap) restic.ID {
	tb := restic.NewTreeJSONBuilder()
	var names []string
	for name := range tree {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		item := tree[name]
		switch elem := item.(type) {
		case TestFile:
			err := tb.AddNode(&restic.Node{
				Name: name,
				Type: restic.NodeTypeFile,
				Size: elem.Size,
			})
			if err != nil {
				panic(err)
			}
		case TestTree:
			id := buildTreeMapExtended(elem, m)
			err := tb.AddNode(&restic.Node{
				Name:    name,
				Subtree: &id,
				Type:    restic.NodeTypeDir,
			})
			if err != nil {
				panic(err)
			}
		case TestNodeExtended:
			err := tb.AddNode(&restic.Node{
				Name:    name,
				Type:    elem.Type,
				Size:    elem.Size,
				Content: elem.Content,
			})
			if err != nil {
				panic(err)
			}
		default:
			panic(fmt.Sprintf("invalid type %T", elem))
		}
	}

	buf, err := tb.Finalize()
	if err != nil {
		panic(err)
	}

	id := restic.Hash(buf)

	if _, ok := m[id]; !ok {
		m[id] = buf
	}

	return id
}

func TestRechunkRewriter(t *testing.T) {
	// test cases preparation:
	// 1) prepare tree (srcTree, dstWantsTree): Node representation or TestTree representaion (like in walker_test)
	// 2) prepare blobIDs map: (srcBlobIDs, dstBlobIDs) of random IDs (with restic.ID.NewRandomID())
	//
	// test procedure:
	// 1) convert srcTree and dstWantsTree to node format if not already is
	// 2) push both tree to repository and get root tree IDs
	// 3) rewrite srcTree with RewriteTree (-> dstTestsTree)
	// 4) push dstTestsTree to repository and get root tree ID
	// 5) ensure root IDs of dstWantsTree and dstTestsTree match

	blobIDsMap := map[string]BlobIDsPair{
		"a":        generateBlobIDsPair(1, 1),
		"subdir/a": generateBlobIDsPair(30, 31),
		"x":        generateBlobIDsPair(42, 41),
		"0":        generateBlobIDsPair(0, 0),
	}
	rechunkBlobsMap := map[hashType]BlobIDsPair{}
	for _, v := range blobIDsMap {
		rechunkBlobsMap[hashOfIDs(v.srcBlobIDs)] = v
	}

	tree := TestTree{
		"zerofile": TestNodeExtended{
			Type:    restic.NodeTypeFile,
			Size:    0,
			Content: restic.IDs{},
		},
		"a": TestNodeExtended{
			Type:    restic.NodeTypeFile,
			Size:    1,
			Content: blobIDsMap["a"].srcBlobIDs,
		},
		"subdir": TestTree{
			"a": TestNodeExtended{
				Type:    restic.NodeTypeFile,
				Size:    3,
				Content: blobIDsMap["subdir/a"].srcBlobIDs,
			},
			"x": TestNodeExtended{
				Type:    restic.NodeTypeFile,
				Size:    2,
				Content: blobIDsMap["x"].srcBlobIDs,
			},
			"subdir": TestTree{
				"dup_x": TestNodeExtended{
					Type:    restic.NodeTypeFile,
					Size:    2,
					Content: blobIDsMap["x"].srcBlobIDs,
				},
				"nonregularfile": TestNodeExtended{
					Type: restic.NodeTypeSymlink,
				},
			},
		},
	}
	wants := TestTree{
		"zerofile": TestNodeExtended{
			Type:    restic.NodeTypeFile,
			Size:    0,
			Content: restic.IDs{},
		},
		"a": TestNodeExtended{
			Type:    restic.NodeTypeFile,
			Size:    1,
			Content: blobIDsMap["a"].dstBlobIDs,
		},
		"subdir": TestTree{
			"a": TestNodeExtended{
				Type:    restic.NodeTypeFile,
				Size:    3,
				Content: blobIDsMap["subdir/a"].dstBlobIDs,
			},
			"x": TestNodeExtended{
				Type:    restic.NodeTypeFile,
				Size:    2,
				Content: blobIDsMap["x"].dstBlobIDs,
			},
			"subdir": TestTree{
				"dup_x": TestNodeExtended{
					Type:    restic.NodeTypeFile,
					Size:    2,
					Content: blobIDsMap["x"].dstBlobIDs,
				},
				"nonregularfile": TestNodeExtended{
					Type: restic.NodeTypeSymlink,
				},
			},
		},
	}

	srcRepo, srcRoot := BuildTreeMapExtended(tree)
	_, wantsRoot := BuildTreeMapExtended(wants)

	testsRepo := WritableTreeMap{TreeMap{}}
	rechunker := NewRechunker(srcRepo, testsRepo, 0)
	rechunker.rechunkBlobsMap = rechunkBlobsMap
	testsRoot, err := rechunker.RewriteTree(context.TODO(), srcRoot)
	if err != nil {
		t.Error(err)
	}
	if wantsRoot != testsRoot {
		t.Errorf("tree mismatch. wants: %v, tests: %v", wantsRoot, testsRoot)
	}
}
