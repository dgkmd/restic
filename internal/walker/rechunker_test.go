package walker

import (
	"context"
	"testing"

	"github.com/restic/chunker"
	"github.com/restic/restic/internal/archiver"
	"github.com/restic/restic/internal/repository"
	"github.com/restic/restic/internal/restic"
	rtest "github.com/restic/restic/internal/test"
	"golang.org/x/sync/errgroup"
)

// TODO: implement two test functions, TestRechunker and TestRewriter.

// TestRechunker:
// Generate random files ([]byte) of various size (refer to archiver_test.go).
// Optionally include duplicate files.
// Chooose two arbitrary chunker polynomials (src and dst).
// Create test nodes. It suffices to have name, nodeType and content field.
// At preparation, chunk files by each of the two polynomials.
// Keep src chunks at mock LoadBlob (srcRepo), put src blob IDs in content fields,
// and put dst blob IDs in SaveBlob (dstRepo).
// wants: dstRepo to have all dst blobs computed from dst polynomials.

// TestRewriter:
// Generate arbitrary tree hierarchy that consists of various node types.
// Also include various metadata to test metadata preservation.
// Prepare mock rechunkBlobsMap. (It doesn't have to be generated by real chunking)
// wants: dstRepo to have all tree blobs that are expected (substitued contents).
// Also include expected fail test case, in which a file with no matching key in rechunkBlobsMap exists.
// Number of dst blobs: max(round(an+b), 1),
// where n: number of src blobs, a~Uniform(0.9, 1.1) and b~Uniform(-2.0, 2.0).
// And each blob ID should be randomly generated 32 bytes string (SHA256 format).


func TestRechunker(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	repository.TestUseLowSecurityKDFParameters(t)

	// prepare repositories
	srcRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})
	dstTestsRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})
	dstWantsRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})

	srcChunkerParam, _ := chunker.RandomPolynomial()
	dstChunkerParam, _ := chunker.RandomPolynomial()

	repoVer := uint(restic.StableRepoVersion)
	repoPw := rtest.TestPassword
	_ = srcRepo.Init(ctx, repoVer, repoPw, &srcChunkerParam)
	_ = dstTestsRepo.Init(ctx, repoVer, repoPw, &dstChunkerParam)
	_ = dstWantsRepo.Init(ctx, repoVer, repoPw, &dstChunkerParam)

	// prepare test data
	src := archiver.TestDir{
		"zero": archiver.TestFile{Content: ""},
		"tiny": archiver.TestFile{Content: string(rtest.Random(42, 123))},
		"small": archiver.TestFile{Content: string(rtest.Random(42, 123_456))},
		"floppy": archiver.TestFile{Content: string(rtest.Random(42, 1_234_567))},
		"medium": archiver.TestFile{Content: string(rtest.Random(42, 12_345_678))},
		"large": archiver.TestFile{Content: string(rtest.Random(42, 123_456_789))},
	}
	tempDir := rtest.TempDir(t)
	archiver.TestCreateFiles(t, tempDir, src)
	src = nil

	// archive data to the repos with archiver
	srcSn := archiver.TestSnapshot(t, srcRepo, tempDir, nil)
	_ = archiver.TestSnapshot(t, dstWantsRepo, tempDir, nil)

	// do rechunking to dstTestRepo
	wg, wgCtx := errgroup.WithContext(ctx)
	dstTestsRepo.StartPackUploader(wgCtx, wg)
	rechunker := NewFileRechunker(srcRepo, dstTestsRepo, dstTestsRepo.Config().ChunkerPolynomial)
	rechunker.RechunkData(ctx, *srcSn.Tree)
	dstTestsRepo.Flush(ctx)

	// compare data blobs between dstWantsRepo and dstTestRepo
	blobWants := restic.IDs{}
	dstWantsRepo.ListBlobs(ctx, func(pb restic.PackedBlob) {
		if pb.Type == restic.DataBlob {
			blobWants = append(blobWants, pb.ID)
		}
	})

	// blobTests := restic.IDs{}
	// dstTestsRepo.ListBlobs(ctx, func(pb restic.PackedBlob) {
	// 	if pb.Type == restic.DataBlob {
	// 		blobTests = append(blobTests, pb.ID)
	// 	}
	// })
	// fmt.Printf("Wanted blobs: %v\n", blobWants.String())
	// fmt.Printf("Tested blobs: %v\n", blobTests.String())

	for _, blobID := range blobWants {
		_, ok := dstTestsRepo.LookupBlobSize(restic.DataBlob, blobID)
		if !ok {
			t.Errorf("Blob missing: %v", blobID)
		}
	}
}