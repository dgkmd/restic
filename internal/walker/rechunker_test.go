package walker

import (
	"context"
	"fmt"
	"testing"

	"github.com/restic/chunker"
	"github.com/restic/restic/internal/archiver"
	"github.com/restic/restic/internal/fs"
	"github.com/restic/restic/internal/repository"
	"github.com/restic/restic/internal/restic"
	rtest "github.com/restic/restic/internal/test"
	"golang.org/x/sync/errgroup"
)

// TODO: implement two test functions, TestRechunker and TestRewriter.

// TestRechunker:
// Generate random files ([]byte) of various size (refer to archiver_test.go).
// Optionally include duplicate files.
// Chooose two arbitrary chunker polynomials (src and dst).
// Create test nodes. It suffices to have name, nodeType and content field.
// At preparation, chunk files by each of the two polynomials.
// Keep src chunks at mock LoadBlob (srcRepo), put src blob IDs in content fields,
// and put dst blob IDs in SaveBlob (dstRepo).
// wants: dstRepo to have all dst blobs computed from dst polynomials.

// TestRewriter:
// Generate arbitrary tree hierarchy that consists of various node types.
// Also include various metadata to test metadata preservation.
// Prepare mock rechunkBlobsMap. (It doesn't have to be generated by real chunking)
// wants: dstRepo to have all tree blobs that are expected (substitued contents).
// Also include expected fail test case, in which a file with no matching key in rechunkBlobsMap exists.
// Number of dst blobs: max(round(an+b), 1),
// where n: number of src blobs, a~Uniform(0.9, 1.1) and b~Uniform(-2.0, 2.0).
// And each blob ID should be randomly generated 32 bytes string (SHA256 format).


func TestRechunker(t *testing.T) {

	// prepare repositories
	srcChunkerPol, _ := chunker.RandomPolynomial()
	dstChunkerPol, _ := chunker.RandomPolynomial()

	srcRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})
	dstTestsRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})
	dstWantsRepo, _ := repository.New(repository.TestBackend(t), repository.Options{})

	ctx := context.TODO()
	ver := uint(restic.StableRepoVersion)
	pw := rtest.TestPassword
	srcRepo.Init(ctx, ver, pw, &srcChunkerPol)
	dstTestsRepo.Init(ctx, ver, pw, &dstChunkerPol)
	dstWantsRepo.Init(ctx, ver, pw, &dstChunkerPol)

	// prepare test data
	src := archiver.TestDir{
		"aaa": archiver.TestFile{Content: string(rtest.Random(42, 123))},
		"bbb": archiver.TestFile{Content: string(rtest.Random(42, 123456))},
		"ccc": archiver.TestFile{Content: string(rtest.Random(42, 123456789))},
	}
	tempDir := rtest.TempDir(t)
	archiver.TestCreateFiles(t, tempDir, src)
	src = nil

	// archive data to the repos with archiver
	srcSn := archiver.TestSnapshot(t, srcRepo, tempDir, nil)
	dstWantsSn := archiver.TestSnapshot(t, dstWantsRepo, tempDir, nil)

	// do rechunking to dstTestRepo
	rechunker := NewFileRechunker(srcRepo, dstTestsRepo, dstTestsRepo.Config().ChunkerPolynomial)
	rechunker.RechunkData(ctx, *srcSn.Tree)

	// compare data blobs between dstWantsRepo and dstTestRepo
	blobWants := restic.IDs{}
	dstWantsRepo.ListBlobs(ctx, func(pb restic.PackedBlob) {
		if pb.Type == restic.DataBlob {
			blobWants = append(blobWants, pb.ID)
		}
	})
	for _, blobID := range blobWants {
		_, ok := dstTestsRepo.LookupBlobSize(restic.DataBlob, blobID)
		if !ok {
			t.Errorf("Blob mismatch: %v", blobID)
		}
	}
}